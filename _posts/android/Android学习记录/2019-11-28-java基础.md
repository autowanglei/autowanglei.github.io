# java中的参数传递（只有值传递没有引用传递）

Java中只有值传递。

- 基本类型传递的是值的副本，基本类型的副本和原值指向不同的内存地址；

- 引用类型传递的是引用的副本，引用类型的副本和原值指向相同的内存地址；

# static 

## 静态变量生命周期：

1.  **静态局部变量**

   只存在C++/C中，java中没有静态局部变量。

   生命周期为整个源程序，但作用域仅限于局部方法，方法调用结束后，不回收内存。再次进入局部方法，变量值保持上次改变后的值。

2.  **静态全局变量**

   生命周期、作用域为整个源程序。

## static 修饰方法、变量有什么区别

- 关于static和非static变量的区别
  1. static 修饰的变量称为类变量或全局变量或成员变量，在类被加载的时候成员变量即被初始化，与类关联，只要类存在，static变量就存在。非static修饰的成员变量是在对象new出来的时候划分存储空间，是与具体的对象绑定的，该成员变量仅为当前对象所拥有的。

  2. static修饰的变量在加载的时候先于构造方法，加载在内存中的数据共享区-------方法区，而非static的变量在加载的时候，是要创建变量才加载在堆内存中的。

  3. 一个static变量单独划分一块存储空间，不与具体的对象绑定在一起，该存储空间被类的各个对象所共享。static变量值在方法区加载一次，而非static在创建对象时会加载很多次。每次创建都会拷贝一份。
  4. 对象在引用成员变量是直接通过类名.变量名调用，对象在引用实例变量时只能通过对象名.变量名调用。

  5. 在类中调用成员变量时直接调用或者以类名.变量名方式调用，实例变量则用this或者直接调用。
- 关于static方法和非static方法的区别
  1. static修饰的方法也和static变量一样。先于构造方法被加载到方法区，以便共享使用。

  2. static方法中不能使用this或者super关键字，因为static方法是先于对象创建之前就已经加载的方法，是属于类的方法，而this和super指向的是本类的对象或者父类的对象，非静态的方法是属于对象的，方法里可以用this和super。

  3. static方法可以用对象.方法名来调用，也可以用类名.方法名来调用。而非静态的方法只能创建对象后时调用。

  4. static方法是加载一次，被所有的对象所共享。而非静态方法是有多少个对象就拷贝多少次，每个对象只能调用自己的拷贝的方法。

  5. 对象调用非静态的方法时，不考虑线程安全性的问题，而调用静态方法时，要考虑安全性的问题。因为静态方法只有一份。而对象的方法是自己有自己的。

  6. 同一个类中，静态方法中只能访问类中的静态成员。而非静态方法可以访问静态的方法（使用类名调用，或者创创建本类的对象调用）。

# final



## 被final修饰的变量赋值

### 被final修饰的变量：三种赋值方式

1. 在定义时直接赋值。

2. 声明时不赋值，在constructor中赋值（最常用的方式）

3. 声明时不赋值，在构造代码块中赋值

   ```java
    private final int finalVal;
    {
        this.finalVal = 10;
    }
   ```

### 被final static修饰的变量：两种赋值方式

1. 在定义时直接赋值.
2. 在静态代码块里赋值

## final 修饰类、方法、变量、参数有什么区别

- 修饰类(class)

  - 该类不能被继承，提高安全性。
  - 类中的方法不会被覆盖，因此默认都是final的。
  - 用途：设计类时，如果该类不需要有子类，不必要被扩展，类的实现细节不允许被改变，那么就设计成final类。

- 修饰方法(method) 

  - 该方法可以被继承，但是不能被覆盖。
  - 好处：可以防止继承它的子类修改该方法的意义和实现；更为高效，编译器在遇到调用fianal方法转入内嵌机制，提高了执行效率。 
  - 注意：父类中的private成员方法不能被子类覆盖，因此，private方法默认是final型的(可以查看编译后的class文件)

- 修饰变量(variable) 

  - 用final修饰后变为常量。包括静态变量、实例变量和局部变量这三种。
  - 特点：可以先声明，不给初值，这种叫做final空白。但是使用前必须被初始化。一旦被赋值，将不能再被改变。

- 修饰参数(arguments) 

  用final修饰参数时，可以读取该参数，但是不能对其作出修改

# java泛型、类型擦除

## 泛型

将类型当作参数传递给一个类或者是方法。

在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如<T>则会被转译成普通的 Object 类型，如果指定了上限，如< T extends String >则类型参数就被替换成类型上限。 

## 类型擦除

类型擦除指的是通过类型参数合并，将泛型类型实例关联到同一份字节码上。

类型擦除可以简单的理解为将泛型java代码转换为普通java代码，只不过编译器更直接点，将泛型java代码直接转换成普通java 字节码。

