## 知识点总结

### 1.HashMap

1. 存储结构

   数组、链表、红黑树（JDK1.8）

2. 特点

   快速存储、快速查找、可伸缩(负载因子0.75 扩容2倍)

   负载因子较小：浪费存储空间

   负载因子较大：哈希冲突概率增大，降低效率

3. hash算法

   hashCode ^ (hashCode>>16)

4. 数组下标计算

   hash%16

5. 哈希冲突

   不同对象计算出的数组下标相等。

   使用单向链表解决哈希冲突，链表长度大于8，转红黑树

   

### 2.HashTable和ConcurrentHashMap实现线程安全

​	HashTable: 一把synchronized

​	ConcurrentHashMap：分段锁 jdk1.8及以后分段颗粒度减小

1. ### equals() 与 == 的区别是什么 

   - equals()：判断两个对象是否相等

     - 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。  

     - 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。  

   - ==： 判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象  

2.  **hashCode() 的作用是什么** 

    hashCode() 的作用是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。  仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用 。

3.  **hashCode() 和 equals() 之间有什么联系** 

   -  **第一种 不创建“类对应的散列表”** 

      “hashCode() 和 equals() ”没有关系

   -  **第二种 创建“类对应的散列表”** 

       在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：
         1)、如果两个对象相等，那么它们的hashCode()值一定相同。
            这里的相等是指，通过equals()比较两个对象时返回true。
         2)、如果两个对象hashCode()相等，它们并不一定相等。
             因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得     出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。 

     hashCode()相等，通过equals()比较它们也返回true，认为对象相等。 
     

### 4.线程

1. 启动线程的三种方式

   - extends Thread
   - runable
   - callable  可返回结果

2. run() start()

    run方法就是普通对象的普通方法，不会启动线程；

   只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。

3. yield sleep wait

   - yield：是线程类（Thread）的静态方法， 它让掉当前线程 CPU 的时间片，使正在运

     行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可

     能被其他线程获取到。对象的机锁没有被释放 。

   - sleep：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出
     执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞
     争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当
     一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁
     没有被释放，其他线程依然无法访问这个对象。

   - wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一
     个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通
     过notify，notifyAll方法来唤醒等待的线程

4. join

   线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作

5. 创建线程池有哪几种方式

   ①. newFixedThreadPool(int nThreads)

   ②. newCachedThreadPool()

   ③. newSingleThreadExecutor()

   ④. newScheduledThreadPool(int corePoolSize)

6. 线程池都有哪些状态

   线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated

    ![image]( https://raw.githubusercontent.com/autowanglei/autowanglei.github.io/master/_posts/Java学习记录/08000847-0a9caed4d6914485b2f56048c668251a.jpg ) 

   - RUNNING

     (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
     (2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

   -  SHUTDOWN

     (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
     (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

   - STOP

     (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
     (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

   - TIDYING

     (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
     (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
     当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

   -  TERMINATED

     (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
     (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

7. 线程池中 submit()和 execute()方法有什么区别？

   - submit(Callable<T> task)、submit(Runnable task, T result)、submit(Runnable task)归属于ExecutorService接口。
     execute(Runnable command)归属于Executor接口。ExecutorService继承了Executor。
   - submit有返回值，返回 Future ，而execute没有
   -  submit()方便做异常处理。通过Future.get()可捕获异常。 

8. 在 java 程序中怎么保证多线程的运行安全

   - 原子性： 提供互斥访问， 同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
   - 可见性： 一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
   - 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。

9. 死锁

   死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而
   造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于
   死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系
   统层面的一个错误，是进程死锁的简称。

10. 怎么防止死锁

    - 死锁的四个必要条件：
      互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问
      该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    - 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该
      资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    - 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只
      能在使用完后自己释放
    - 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环
      等待资源关系

     这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上

     述条件之 一不满足，就不会发生死锁。 理解了死锁的原因，尤其是产生死锁的四

    个必要条件，就可以最大可能地避免、预 防 解除死锁。

11. ThreadLocal 是什么？有哪些使用场景？
    线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共
    享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。
    但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这
    种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部
    变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

12. 说一下 synchronized 底层实现原理？

    synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入
    到临界区，同时它还可以保证共享变量的内存可见性。

    Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

    - 普通同步方法，锁是当前实例对象
    - 静态同步方法，锁是当前类的class对象
    - 同步方法块，锁是括号里面的对象


### 5.Java中的异常

![image](https://raw.githubusercontent.com/autowanglei/autowanglei.github.io/master/_posts/Java学习记录/Throwable.png) 

### 6.transient： 阻止实例中那些用此关键字修饰的的变量序列化  

### 7.java 中 IO 流分为几种

- 按功能来分：输入流（input）、输出流（output）。

- 按类型来分：字节流和字符流。

### 8.BIO,NIO,AIO 有什么区别

- **BIO (Blocking I/O):** 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。并发处理能力低，在活动连接数不是特别高（小于单机1000）的情况下使用。
- **NIO (New I/O):** NIO是一种同步非阻塞的I/O模型，对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的。

### 9.Arrays.asList()使用指南

 `Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。 

- 如何正确的将数组转换为ArrayList

  -  自己动手实现

  - 最简便的方法(推荐)

    List list = new ArrayList<>(Arrays.asList("a", "b", "c"))

  - 使用 Java8 的Stream(推荐)

    Integer [] myArray = { 1, 2, 3 };
    List myList = Arrays.stream(myArray).collect(Collectors.toList());
    //基本类型也可以实现转换（依赖boxed的装箱操作）
    int [] myArray2 = { 1, 2, 3 };
    List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());

  - 使用 Guava(推荐)

    - 于不可变集合，你可以使用[`ImmutableList`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java)类及其[`of()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L101)与[`copyOf()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableList.java#L225)工厂方法：（参数不能为空）

      ```java
      List<String> il = ImmutableList.of("string", "elements");  // from varargs
      List<String> il = ImmutableList.copyOf(aStringArray);      // from array
      ```

    - 对于可变集合，你可以使用[`Lists`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java)类及其[`newArrayList()`](https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/Lists.java#L87)工厂方法

      List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection
      List<String> l2 = Lists.newArrayList(aStringArray);               // from array
      List<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs

### 10.`Collection.toArray()`方法使用的坑&如何反转数组

​	该方法是一个泛型方法：` T[] toArray(T[] a);` 如果`toArray`方法中没有传递任何参数的话返回的是`Object`类型数组。

```
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
s=list.toArray(new String[0]);//没有指定类型的话会报错
```

由于JVM优化，`new String[0]`作为`Collection.toArray()`方法的参数现在使用更好，`new String[0]`就是起一个模板的作用，指定了返回数组的类型，0是为了节省空间，因为它只是为了说明返回的类型。

### 11.get和post请求的区别

​		get和post从实现本质上讲都是http->TCP协议，是没有区别的。但是GET产生一个TCP数据包；POST产生两个TCP数据包。

- 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
- 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

他们的区别主要体现在以下几个方面：

- get请求用来从服务器上获得资源，而post是用来向服务器提交数据；
-  GET参数通过URL传递，POST放在Request body中, 因此POST比GET更安全，因为GET参数直接暴露在URL上，所以不能用来传递敏感信息。 
- get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；
-  GET请求只能进行url编码，而POST支持多种编码方式。 

### 12.Java集合框架常见问题

1. 说说List,Set,Map三者的区别
2. Arraylist 与 LinkedList 区别

### 13.Java内存区域

运行时数据区域

- **程序计数器**

   程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 

-  **虚拟机栈** 

  每个方法在被调用时都会创建一个栈帧，方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

-  **本地方法栈** 

   本地方法栈和虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 

-  **Java堆** 

  是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，对象实例在这里分配内存。是GC管理的主要区域。

-  **方法区**  

   方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译期编译后的代码等数据。  运行时常量池是方法区的一部分 。

### 14.垃圾回收算法

- 标记-清除算法

   将活跃对象进行标记，将未标记的对象清除。导致会存在很多内存碎片。

- 复制算法

  标记存活对象，将存活对象复制到新的内存空间，清空原来空间。解决了内存碎片问题，缺点：内存浪费，总有一半的内存空间未被利用。

- 标记-整理算法

  移动存活对象，一次性回收需要回收的区域。内存区域快整体移动，影响性能。

- 分代收集

  新生代复制算法,老年代以标记整理算法为主。

### 15.类加载机制和双亲委派模型

- 类加载过程

  - 加载

     加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象。

  - 连接：把类的二进制数据合并到JRE中 

    1. 验证：检验被加载的类是否符合当前虚拟机的要求，有没有危害虚拟机安全的代码。

       

       四种验证：

       - 文件格式验证：主要验证字节流是否符合Class文件格式规范 。
       - 元数据验证：分析字节码描述的信息，是否符合java的语言语法的规范。
       -  字节码验证： 分析数据流和控制，确定语义是合法的，符合逻辑的。 
       - 符号引用验证 ：保证引用一定会被访问到，不会出现类等无法访问的问题 。

    2. 准备：为类的静态变量分配内存，并设置默认初始值。

    3. 解析：将类的二进制数据中的符号引用替换成直接引用。 

  - 初始化： 初始化是为类的静态变量赋予实际的初始值。

  - 使用 new

  - 卸载 GC

- 类加载器

  - 启动类加载器：加载JAVA_HOME/lib目录下
  - 扩展类加载器。加载JAVA_HOME/lib目录下
  - 应用程序类加载器：加载用户路径上指定的类库

- 双亲委派模型

  如果一个类加载器收到了类加载器的请求，首先加载任务委托给父类加载器，依次递归，直到启动类加载器。如果父类加载器能够完成加载任务，就成功返回；否则，子加载器才会尝试自己去加载。

  双亲委派模型的优点：java类随着它的加载器一起具备了一种带有优先级的层次关系，保证java程序稳定运行。

  

  **虚拟机中决定一个类是否唯一：类本身和加载类的类加载器。**

### 16.Spring的IOC容器初始化流程

- IOC 控制反转

  IOC是存放bean（new OrderServiceImpl()）的容器，spring底层实现数据结构为HashMap：

  Map<String, Object> map = new HashMap<>;

  bean存放到IOC容器需要四步：

  - 创建bean   new OrderServiceImpl()

  -  bean属性赋值    

  - bean初始化 ----->  IOC  MAP

  - 回收创建过程的内存，关闭BeanFactory

    

  ​	          map.put("orderServiceImpl",new OrderServiceImpl());

  ​              Controller{

  ​					@Autowired

  ​					OrderServiceImpl orderServiceImpl; //BeanFactory.getBean(){map.get("orderServiceImpl");}

  ​				}

  

### 17.Springboot启动机制

Springboot集成了SpringMVC，内置了Tomcat。启动Tomcat，集成SpringMVC的流程：通过注解@SpringBootApplication->@EnableAutoConfiguration -> @Import 加载spring-boot-autoconfigure中META-INF/spring.factories中所有的配置类，其中EmbeddedWebServerFactoryCustomizerAutoConfiguration、ServletWebServerFactoryAutoConfiguration内置集成和启动Tomcat，配置类WebMvcAutoConfiguration使用EnableWebMvc集成SpringMVC的功能。

### 18.Redis高性能的原因

1. Redis是把数据放在内存中的（内存中数据库存取速度最快），类似HashMap对象。

2. key-value（json ，字符串），数据存储结构简单。

3. Redis为单线程模式，不存在资源竞争问题（内存中的数据，不需要多线程）

4. 多路复用：单个线程来处理很多个请求，按先后顺序放到队列中，先到的请求先处理。

5. resp协议：最简单的指令

   set age 5 --> 将此行命令分解成如下指令：

   *3 --> 表示有三组

   $3 --> 表示第一组的长度

   set --> 代表具体的指令

   $3 --> 表示第二组的长度

   age --> 具体指令

   $1 --> 第三组长度

   5 --> 具体值或指令

### 19.浅谈Http和Https有什么区别

- HTTP是不安全的：数据拦截、数据篡改、数据攻击

  HTTPS的安全需求：数据加密、身份验证 、数据完整性

- 数据加密算法

  对称加密：加解密只有一个密钥

  非对称加密：公钥加密，私钥解密

- HTTPS比HTTP多出的事情：

  - 请求https连接获取证书（公钥）CA证书机构
  - 客户端给服务器发送公钥加密的随机数密文
  - 客户端同时给服务器发送公钥加密的随机数+私钥的密文
  - 服务器根据公钥解出随机数，同时解出私钥
  - 客户端使用非对称加密进行数据传输，客户端使用公钥加密，服务器使用私钥解密。

### 20.你是怎样控制缓存的更新



| 方案名           | 类型      | 实现思路                                                     |
| ---------------- | --------- | ------------------------------------------------------------ |
| 数据实时同步时效 | 增量/主动 | 强一致性，更新数据库后主动淘汰缓存，读请求更新缓存，<br>为避免缓存雪崩，更新缓存的过程需要进行同步控制，同一<br>时间只允许一个请求访问数据库，为了保证数据的一致性，<br>还要加上缓存失效。 |
| 数据准实时更新   | 增量/被动 | 准一致性，更新数据库后，异步更新缓存，使用多线程技术<br>或MQ实现。 |
| 任务调度更新     | 全量/被动 | 最终一致性，采用任务调度框架，按照一定频率更新。             |



绿色建筑大数据平台

单位时间内发电量统计（小时、日、月、年），发电、环境数据监测

监听redis，数据变化后，统计小时、日、月、年发电量，插入MySQL，淘汰缓存

客户端请求：优先查询缓存数据，缓存没有数据，查询MySQL数据

~~~java
    private final ConcurrentHashMap<String, ReentrantLock> locks = new ConcurrentHashMap<>();

    /**
     * 获取发电量
     *
     * @param userId
     * @return
     */
    public BigDecimal getGenerationCapacity(String userId) {
        BigDecimal generationCapacity = null;
        //1.从缓存加载数据
        generationCapacity = getGenerationCapacityFromCache(userId);
        //2.缓存有数据，直接返回
        if (generationCapacity != null) {
            return generationCapacity;
        }
        //竞争锁
        acquireLock(userId);
        try {
            generationCapacity = getGenerationCapacityFromCache(userId);
            //2.缓存有数据，直接返回
            if (generationCapacity != null) {
                return generationCapacity;
            }
            //3.如果没有数据，从MySQL中获取数据
            generationCapacity = getGenerationCapacityFromDB(userId);
            //4.数据库数据不为空，更新缓存
            if (generationCapacity != null) {
                upDateGenerationCapacityCache(userId);
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            releaseLock(userId);
        }
        return generationCapacity;
    }

    private ReentrantLock getLockForKey(String userId){
        ReentrantLock lock = new ReentrantLock();
        //把新锁添加到locks中，如果成功（locks中不存在同一key的锁）使用新锁，如果失败使用locks集合中的锁
        ReentrantLock previous = locks.putIfAbsent(userId, lock);
        return previous == null ? lock : previous;
    }

    /**
     * 从缓存获取数据
     *
     * @param userId
     * @return
     */
    private BigDecimal getGenerationCapacityFromCache(String userId) {
        BigDecimal generationCapacity = null;
        return generationCapacity;
    }

    /**
     * 更新缓存
     *
     * @param userId
     * @return
     */
    private void upDateGenerationCapacityCache(String userId) {

    }

    /**
     * 从DB获取数据
     *
     * @param userId
     * @return
     */
    private BigDecimal getGenerationCapacityFromDB(String userId) {
        BigDecimal generationCapacity = null;
        return generationCapacity;
    }

    /**
     * 竞争锁
     *
     * @param useId
     */
    private void acquireLock(String useId) {
        ReentrantLock lock = getLockForKey(useId);
        lock.lock();
    }

    /**
     * 释放锁
     *
     * @param useId
     */
    private void releaseLock(String useId) {
        ReentrantLock lock = getLockForKey(useId);
        if(lock.isHeldByCurrentThread()){
            lock.unlock();
        }
    }
~~~







### 21









