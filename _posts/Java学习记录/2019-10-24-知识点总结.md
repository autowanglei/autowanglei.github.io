## 知识点总结

### 1.HashMap

1. 存储结构

   数组、链表、红黑树（JDK1.8）

2. 特点

   快速存储、快速查找、可伸缩(负载因子0.75 扩容2倍)

   负载因子较小：浪费存储空间

   负载因子较大：哈希冲突概率增大，降低效率

3. hash算法

   hashCode ^ (hashCode>>16)

4. 数组下标计算

   hash%16

5. 哈希冲突

   不同对象计算出的数组下标相等。

   使用单向链表解决哈希冲突，链表长度大于8，转红黑树

   

### 2.HashTable和ConcurrentHashMap实现线程安全

​	HashTable: 一把synchronized

​	ConcurrentHashMap：分段锁 jdk1.8及以后分段颗粒度减小

1. ### equals() 与 == 的区别是什么 

   - equals()：判断两个对象是否相等

     - 类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。  

     - 类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。  

   - ==： 判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象  

2.  **hashCode() 的作用是什么** 

    hashCode() 的作用是**获取哈希码**，也称为散列码；它实际上是返回一个int整数。这个**哈希码的作用**是确定该对象在哈希表中的索引位置。  仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用 。

3.  **hashCode() 和 equals() 之间有什么联系** 

   -  **第一种 不创建“类对应的散列表”** 

      “hashCode() 和 equals() ”没有关系

   -  **第二种 创建“类对应的散列表”** 

       在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：
         1)、如果两个对象相等，那么它们的hashCode()值一定相同。
            这里的相等是指，通过equals()比较两个对象时返回true。
         2)、如果两个对象hashCode()相等，它们并不一定相等。
             因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得     出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。 

     hashCode()相等，通过equals()比较它们也返回true，认为对象相等。 
     

### 4.线程

1. 启动线程的三种方式

   - extends Thread
   - runable
   - callable  可返回结果

2. run() start()

    run方法就是普通对象的普通方法，不会启动线程；

   只有调用了start()后，Java才会将线程对象和操作系统中实际的线程进行映射，再来执行run方法。

3. yield sleep wait

   - yield：是线程类（Thread）的静态方法， 它让掉当前线程 CPU 的时间片，使正在运

     行中的线程重新变成就绪状态，并重新竞争 CPU 的调度权。它可能会获取到，也有可

     能被其他线程获取到。对象的机锁没有被释放 。

   - sleep：方法是线程类（Thread）的静态方法，让调用线程进入睡眠状态，让出
     执行机会给其他线程，等到休眠时间结束后，线程进入就绪状态和其他线程一起竞
     争cpu的执行时间。因为sleep() 是static静态的方法，他不能改变对象的机锁，当
     一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的机锁
     没有被释放，其他线程依然无法访问这个对象。

   - wait()：wait()是Object类的方法，当一个线程执行到wait方法时，它就进入到一
     个和该对象相关的等待池，同时释放对象的机锁，使得其他线程能够访问，可以通
     过notify，notifyAll方法来唤醒等待的线程

4. join

   线程A，执行了线程B的join方法，线程A必须要等待B执行完成了以后，线程A才能继续自己的工作

5. 创建线程池有哪几种方式

   ①. newFixedThreadPool(int nThreads)

   ②. newCachedThreadPool()

   ③. newSingleThreadExecutor()

   ④. newScheduledThreadPool(int corePoolSize)

6. 线程池都有哪些状态

   线程池有5种状态：Running、ShutDown、Stop、Tidying、Terminated

    ![image](https://images0.cnblogs.com/blog/497634/201401/08000847-0a9caed4d6914485b2f56048c668251a.jpg) 

   - RUNNING

     (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。
     (2) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

   -  SHUTDOWN

     (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。
     (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

   - STOP

     (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。
     (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

   - TIDYING

     (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。
     (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。
     当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

   -  TERMINATED

     (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。
     (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

7. 线程池中 submit()和 execute()方法有什么区别？

   - submit(Callable<T> task)、submit(Runnable task, T result)、submit(Runnable task)归属于ExecutorService接口。
     execute(Runnable command)归属于Executor接口。ExecutorService继承了Executor。
   - submit有返回值，返回 Future ，而execute没有
   -  submit()方便做异常处理。通过Future.get()可捕获异常。 

8. 在 java 程序中怎么保证多线程的运行安全

   - 原子性： 提供互斥访问， 同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）；
   - 可见性： 一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）；
   - 有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）。

9. 死锁

   死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而
   造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于
   死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系
   统层面的一个错误，是进程死锁的简称。

10. 怎么防止死锁

    - 死锁的四个必要条件：
      互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问
      该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
    - 请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该
      资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
    - 不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只
      能在使用完后自己释放
    - 环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环
      等待资源关系

     这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上

     述条件之 一不满足，就不会发生死锁。 理解了死锁的原因，尤其是产生死锁的四

    个必要条件，就可以最大可能地避免、预 防 解除死锁。

11. ThreadLocal 是什么？有哪些使用场景？
    线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共
    享。Java提供ThreadLocal类来支持线程局部变量，是一种实现线程安全的方式。
    但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这
    种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部
    变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。

12. 说一下 synchronized 底层实现原理？

    synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入
    到临界区，同时它还可以保证共享变量的内存可见性。

    Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

    - 普通同步方法，锁是当前实例对象
    - 静态同步方法，锁是当前类的class对象
    - 同步方法块，锁是括号里面的对象


### 5.Java中的异常

![image](https://raw.githubusercontent.com/autowanglei/autowanglei.github.io/master/_posts/Java学习记录/Throwable.png) 